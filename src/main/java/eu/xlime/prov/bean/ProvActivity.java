package eu.xlime.prov.bean;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.persistence.Id;

import eu.xlime.bean.UIDate;
import eu.xlime.bean.XLiMeResource;
import eu.xlime.summa.bean.UIEntity;

/**
 * Some computational activity which produced some xLiMe data.
 * 
 * Simplified version of the Activity as specified by <b>PROV-O</b>ntology.
 * 
 * @author rdenaux
 *
 */
public class ProvActivity implements XLiMeResource {

	private static final long serialVersionUID = -21760154655937171L;

	@Id
	private String url;

	/**
	 * The time when this {@link ProvActivity} started
	 */
	private UIDate startedAtTime;
	
	/**
	 * The time when this {@link ProvActivity} finished
	 */
	private UIDate endedAtTime;
	
	/**
	 * List (possibly empty) of {@link ProvEntity} urls used by this {@link ProvActivity}.
	 */
	private List<String> usedEntityUrls = new ArrayList<String>();
	
	/**
	 * List (possibly empty) of {@link UIEntity} urls of people and resources (i.e. programs, servers) associated with this {@link ProvActivity}.
	 */
	private List<String> associatedWithEntityUrls = new ArrayList<String>();
	
	/**
	 * Provides a summary of the data generated by this {@link ProvActivity}. 
	 * 
	 * This can be different per type of activity. For example and activity which consumes a stream of microposts and produces 
	 * annotations could produce a map of counts such as: Map("items-consumed" -> 50, "annotations-created" -> 150) 
	 */
	private Map<String, Long> counts = new HashMap<String, Long>();

	/**
	 * Provides an indication about the the performance achieved during the execution of this {@link ProvActivity} by
	 * relating some count (e.g. number of items created) to some time frame (e.g. a second).
	 */
	private Throughput throughput;

	public String getUrl() {
		return url;
	}

	public void setUrl(String url) {
		this.url = url;
	}

	public UIDate getStartedAtTime() {
		return startedAtTime;
	}

	public void setStartedAtTime(UIDate startedAtTime) {
		this.startedAtTime = startedAtTime;
	}

	public UIDate getEndedAtTime() {
		return endedAtTime;
	}

	public void setEndedAtTime(UIDate endedAtTime) {
		this.endedAtTime = endedAtTime;
	}

	public List<String> getUsedEntityUrls() {
		return usedEntityUrls;
	}

	public void setUsedEntityUrls(List<String> usedEntityUrls) {
		this.usedEntityUrls = usedEntityUrls;
	}

	public List<String> getAssociatedWithEntityUrls() {
		return associatedWithEntityUrls;
	}

	public void setAssociatedWithEntityUrls(List<String> associatedWithEntityUrls) {
		this.associatedWithEntityUrls = associatedWithEntityUrls;
	}

	public Map<String, Long> getCounts() {
		return counts;
	}

	public void setCounts(Map<String, Long> counts) {
		this.counts = counts;
	}

	public Throughput getThroughput() {
		return throughput;
	}

	public void setThroughput(Throughput throughput) {
		this.throughput = throughput;
	}

	@Override
	public String toString() {
		final int maxLen = 5;
		return String
				.format("ProvActivity [url=%s, startedAtTime=%s, endedAtTime=%s, usedEntityUrls=%s, associatedWithEntityUrls=%s, counts=%s, throughput=%s]",
						url,
						startedAtTime,
						endedAtTime,
						usedEntityUrls != null ? toString(usedEntityUrls,
								maxLen) : null,
						associatedWithEntityUrls != null ? toString(
								associatedWithEntityUrls, maxLen) : null,
						counts != null ? toString(counts.entrySet(), maxLen)
								: null, throughput);
	}

	private String toString(Collection<?> collection, int maxLen) {
		StringBuilder builder = new StringBuilder();
		builder.append("[");
		int i = 0;
		for (Iterator<?> iterator = collection.iterator(); iterator.hasNext()
				&& i < maxLen; i++) {
			if (i > 0)
				builder.append(", ");
			builder.append(iterator.next());
		}
		builder.append("]");
		return builder.toString();
	}

}
